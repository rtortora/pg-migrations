{"version":3,"sources":["../../src/commands/do_run.js"],"names":["doRun","host","migration","direction","args","Error","withMigrationLock","migrationStatusMap","refresh","migrations","force","get","key","applied","sortedUnappliedKeys","Array","from","keys","local","sort","push","appliedKeys","sortedKeys","migrated_at","targetKey","length","dryrun","console","log","path","conn","module","require","default","withTransaction","bind","setMigrationStatus"],"mappings":"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","file":"do_run.js","sourcesContent":["import sortBy from 'lodash.sortby';\nimport filter from 'lodash.filter';\nimport isFunction from 'lodash.isfunction';\n\nexport default async function doRun(host, migration, direction, args) {\n  if (direction != \"up\" && direction != \"down\") {\n    throw new Error(`Unhandled migration direction, must be 'up' or 'down' but was: '${direction}'`);\n  }\n  await host.withMigrationLock(async ()=>{\n    const migrationStatusMap = await host.migrationStatusMap({ refresh: true });\n\n    // Determine which migrations to run\n    let migrations;\n    if (migration) {\n      if (args.force ||\n          (direction == 'up' && !migrationStatusMap.get(migration.key).applied) ||\n          (direction == 'down' && migrationStatusMap.get(migration.key).applied)) {\n        migrations = [migration];\n      } else {\n        migrations = [];\n      }\n    } else if (direction == 'up') {\n      migrations = [];\n      const sortedUnappliedKeys = filter(Array.from(migrationStatusMap.keys()), (key)=>{\n        return !migrationStatusMap.get(key).applied && migrationStatusMap.get(key).local;\n      }).sort();\n      for (let key of sortedUnappliedKeys) {\n        migrations.push(migrationStatusMap.get(key).local);\n      }\n    } else if (direction == 'down') {\n      const appliedKeys = filter(Array.from(migrationStatusMap.keys()), (key)=>{\n        return migrationStatusMap.get(key).applied && migrationStatusMap.get(key).local;\n      });\n      const sortedKeys = sortBy(appliedKeys, (key)=>{\n        return migrationStatusMap.get(key).applied.migrated_at;\n      });\n      const targetKey = sortedKeys[sortedKeys.length - 1];\n      if (targetKey) {\n        migrations = [migrationStatusMap.get(targetKey).local];\n      } else {\n        migrations = [];\n      }\n    } else {\n      throw new Error(`Unexpected`);\n    }\n\n    if (args.dryrun) {\n      console.log(`Dry run, would run '${direction}' on these migrations in order: (x${migrations.length})`);\n      for (let migration of migrations) {\n        console.log(`${migration.key} ${migration.path}`);\n      }\n      return;\n    }\n\n    // Actually run the migrations\n    const conn = await host.conn();\n    for (let migration of migrations) {\n      const module = require(migration.path).default;\n      if (isFunction(module[direction])) {\n        console.log(`.... ${direction} ${migration.key} ${migration.path}`);\n        await host.withTransaction(async()=>{\n          await (module[direction].bind(module, conn)());\n          await host.setMigrationStatus(migration, direction);\n          console.log(`OKAY ${direction} ${migration.key} ${migration.path}`);\n        });\n      } else {\n        await host.withTransaction(async()=>{\n          await host.setMigrationStatus(migration, direction);\n          console.log(`SKIP ${direction} ${migration.key} ${migration.path} (no such direction ${direction})`);\n        });\n      }\n    }\n\n    console.log(`Complete!`);\n  });\n}\n"]}