{"version":3,"sources":["../../src/commands/do_run.js"],"names":["sortBy","require","module","exports","host","migration","direction","args","Error","withMigrationLock","migrationStatusMap","refresh","migrations","force","get","key","applied","sortedUnappliedKeys","Array","from","keys","filter","local","sort","push","appliedKeys","sortedKeys","migrated_at","targetKey","length","dryrun","console","log","path","conn","default","withTransaction","bind","setMigrationStatus","exception","process","exit","doRun"],"mappings":"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","file":"do_run.js","sourcesContent":["const sortBy = require('lodash.sortby');\n\nmodule.exports = async function doRun(host, migration, direction, args) {\n  if (direction != \"up\" && direction != \"down\") {\n    throw new Error(`Unhandled migration direction, must be 'up' or 'down' but was: '${direction}'`);\n  }\n  await host.withMigrationLock(async ()=>{\n    const migrationStatusMap = await host.migrationStatusMap({ refresh: true });\n    // Determine which migrations to run\n    let migrations;\n    if (migration) {\n      if (args.force ||\n          (direction == 'up' && !migrationStatusMap.get(migration.key).applied) ||\n          (direction == 'down' && migrationStatusMap.get(migration.key).applied)) {\n        migrations = [migration];\n      } else {\n        migrations = [];\n      }\n    } else if (direction == 'up') {\n      migrations = [];\n      const sortedUnappliedKeys = Array.from(migrationStatusMap.keys()).filter((key)=>{\n        return !migrationStatusMap.get(key).applied && migrationStatusMap.get(key).local;\n      }).sort();\n      for (let key of sortedUnappliedKeys) {\n        migrations.push(migrationStatusMap.get(key).local);\n      }\n    } else if (direction == 'down') {\n      const appliedKeys = Array.from(migrationStatusMap.keys()).filter((key)=>{\n        return migrationStatusMap.get(key).applied && migrationStatusMap.get(key).local;\n      });\n      const sortedKeys = sortBy(appliedKeys, (key)=>{\n        return migrationStatusMap.get(key).applied.migrated_at;\n      });\n      const targetKey = sortedKeys[sortedKeys.length - 1];\n      if (targetKey) {\n        migrations = [migrationStatusMap.get(targetKey).local];\n      } else {\n        migrations = [];\n      }\n    } else {\n      throw new Error(`Unexpected`);\n    }\n\n    if (args.dryrun) {\n      console.log(`Dry run, would run '${direction}' on these migrations in order: (x${migrations.length})`);\n      for (let migration of migrations) {\n        console.log(`${migration.key} ${migration.path}`);\n      }\n      return;\n    }\n\n    // Actually run the migrations\n    const conn = await host.conn();\n    for (let migration of migrations) {\n      let module = require(migration.path);\n      if (module.default) {\n        module = module.default;\n      }\n      if (typeof(module[direction]) === 'function') {\n        console.log(`.... ${direction} ${migration.key} ${migration.path}`);\n        try {\n          await host.withTransaction(async()=>{\n            await (module[direction].bind(module, conn)());\n            await host.setMigrationStatus(migration, direction);\n            console.log(`OKAY ${direction} ${migration.key} ${migration.path}`);\n          });\n        } catch(exception) {\n          console.log(`FAIL ${direction} ${migration.key} ${migration.path}`);\n          console.log(exception);\n          process.exit(1);\n        }\n      } else {\n        await host.withTransaction(async()=>{\n          await host.setMigrationStatus(migration, direction);\n          throw new Error(`${direction} ${migration.key} ${migration.path} (no such function ${direction})`);\n        });\n      }\n    }\n\n    console.log(`Complete!`);\n  });\n}\n"]}