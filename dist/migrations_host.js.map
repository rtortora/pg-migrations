{"version":3,"sources":["../src/migrations_host.js"],"names":["FS","require","Path","CONFIG_FILENAME","module","exports","MigrationsHost","constructor","rootPath","process","cwd","config","_config","exists","join","constants","R_OK","dirname","Error","loadedConfig","default","Object","assign","configPath","migrationsTableName","migrationsRelPath","migrationsPath","conn","bootstrap","_conn","getConnection","_connecting","_connected","connect","_bootstrapped","query","localMigrationsMap","refresh","_localMigrationsMap","files","readdir","Map","filename","keySearch","match","key","set","path","migrationStatusMap","_migrationStatusMap","migration","local","statuses","rows","status","applied","get","setMigrationStatus","basename","withMigrationLock","fn","_withMigrationLock","withTransaction","_withTransaction","result","exception"],"mappings":";;AAAA,MAAMA,KAAKC,QAAQ,YAAR,CAAX;;AACA,MAAMC,OAAOD,QAAQ,MAAR,CAAb;;AAEA,MAAME,kBAAkB,sBAAxB;AAEA;;;;AAGAC,OAAOC,OAAP,GAAiB,MAAMC,cAAN,CAAqB;AACpCC,cAAYC,WAAW,IAAvB,EAA6B;AAC3B,SAAKA,QAAL,GAAgBA,YAAYC,QAAQC,GAAR,EAA5B;AACD;AAED;;;;;;AAIMC,QAAN,GAAe;AAAA;;AAAA;AACb,UAAI,CAAC,MAAKC,OAAV,EAAmB;AACjB,eAAO,IAAP,EAAa;AACX,oBAAUZ,GAAGa,MAAH,CAAUX,KAAKY,IAAL,CAAU,MAAKN,QAAf,EAAyBL,eAAzB,CAAV,EAAqDH,GAAGe,SAAH,CAAaC,IAAlE,CAAV,EAAmF;AACjF;AACD;;AACD,gBAAKR,QAAL,GAAgBN,KAAKe,OAAL,CAAa,MAAKT,QAAlB,CAAhB;;AACA,cAAI,MAAKA,QAAL,IAAiB,GAArB,EAA0B;AACxB,kBAAM,IAAIU,KAAJ,CAAW,eAAcf,eAAgB,EAAzC,CAAN;AACD;AACF;;AACD,YAAIgB,eAAelB,QAAQC,KAAKY,IAAL,CAAU,MAAKN,QAAf,EAAyBL,eAAzB,CAAR,CAAnB;;AACA,YAAIgB,aAAaC,OAAjB,EAA0B;AACxBD,yBAAeA,aAAaC,OAA5B;AACD;;AACD,cAAKR,OAAL,GAAeS,OAAOC,MAAP,CAAc;AAC3BC,sBAAYrB,KAAKY,IAAL,CAAU,MAAKN,QAAf,EAAyBL,eAAzB,CADe;AAE3BqB,+BAAqB,YAFM;AAG3BC,6BAAmB;AAHQ,SAAd,EAIZN,YAJY,CAAf;AAKA,cAAKP,OAAL,CAAac,cAAb,GAA8BxB,KAAKY,IAAL,CAAU,MAAKN,QAAf,EAAyB,MAAKI,OAAL,CAAaa,iBAAtC,CAA9B;AACD;;AACD,aAAO,MAAKb,OAAZ;AAtBa;AAuBd;AAED;;;;;;;AAKMe,MAAN,CAAW;AAAEC,gBAAY;AAAd,MAAwB,EAAnC,EAAuC;AAAA;;AAAA;AACrC,UAAI,CAAC,OAAKC,KAAV,EAAiB;AACf,cAAMlB,eAAe,OAAKA,MAAL,EAArB;;AACA,YAAI,OAAOA,OAAOmB,aAAd,KAAiC,UAArC,EAAiD;AAC/C,gBAAM,IAAIZ,KAAJ,CAAW,GAAEP,OAAOY,UAAW,gDAA+C,OAAOZ,OAAOmB,aAAe,GAA3G,CAAN;AACD;;AACD,eAAKD,KAAL,SAAmBlB,OAAOmB,aAAP,EAAnB;;AACA,YAAI,CAAC,OAAKD,KAAL,CAAWE,WAAZ,IAA2B,CAAC,OAAKF,KAAL,CAAWG,UAA3C,EAAuD;AACrD,gBAAM,OAAKH,KAAL,CAAWI,OAAX,EAAN;AACD;AACF;;AACD,UAAIL,aAAa,CAAC,OAAKM,aAAvB,EAAsC;AACpC,cAAMvB,eAAe,OAAKA,MAAL,EAArB;AACA,cAAM,OAAKkB,KAAL,CAAWM,KAAX,CAAkB;sCACQxB,OAAOa,mBAAoB;;;;;OADrD,CAAN;AAOA,eAAKU,aAAL,GAAqB,IAArB;AACD;;AACD,aAAO,OAAKL,KAAZ;AAtBqC;AAuBtC;AAED;;;;;;;AAKMO,oBAAN,CAAyB;AAAEC,cAAU;AAAZ,MAAsB,EAA/C,EAAmD;AAAA;;AAAA;AACjD,UAAI,CAAC,OAAKC,mBAAN,IAA6BD,OAAjC,EAA0C;AACxC,cAAM1B,eAAe,OAAKA,MAAL,EAArB;AACA,cAAM4B,cAAcvC,GAAGwC,OAAH,CAAW7B,OAAOe,cAAlB,CAApB;AACA,eAAKY,mBAAL,GAA2B,IAAIG,GAAJ,EAA3B;;AACA,aAAK,IAAIC,QAAT,IAAqBH,KAArB,EAA4B;AAC1B,gBAAMI,YAAYD,SAASE,KAAT,CAAe,gBAAf,CAAlB;;AACA,cAAID,SAAJ,EAAe;AACb,kBAAME,MAAMF,UAAU,CAAV,CAAZ;;AACA,mBAAKL,mBAAL,CAAyBQ,GAAzB,CAA6BD,GAA7B,EAAkC;AAChCA,iBADgC;AAEhCH,sBAFgC;AAGhCK,oBAAM7C,KAAKY,IAAL,CAAUH,OAAOe,cAAjB,EAAiCgB,QAAjC;AAH0B,aAAlC;AAKD;AACF;AACF;;AACD,aAAO,OAAKJ,mBAAZ;AAjBiD;AAkBlD;AAED;;;;;;;AAKMU,oBAAN,CAAyB;AAAEX,cAAU;AAAZ,MAAsB,EAA/C,EAAmD;AAAA;;AAAA;AACjD,UAAI,CAAC,OAAKY,mBAAN,IAA6BZ,OAAjC,EAA0C;AACxC,cAAMD,2BAA2B,OAAKA,kBAAL,EAAjC;AACA,eAAKa,mBAAL,GAA2B,IAAIR,GAAJ,EAA3B;;AACA,aAAI,IAAI,CAACI,GAAD,EAAMK,SAAN,CAAR,IAA4Bd,kBAA5B,EAAgD;AAC9C,iBAAKa,mBAAL,CAAyBH,GAAzB,CAA6BD,GAA7B,EAAkC;AAAEM,mBAAOD;AAAT,WAAlC;AACD;;AAED,cAAMvC,eAAe,OAAKA,MAAL,EAArB;AACA,cAAMgB,aAAa,OAAKA,IAAL,CAAU;AAAEC,qBAAW;AAAb,SAAV,CAAnB;AACA,cAAMwB,WAAW,OAAOzB,KAAKQ,KAAL,CAAY,iDAAgDxB,OAAOa,mBAAoB,0BAAvF,CAAP,EAA0H6B,IAA3I;;AACA,aAAK,IAAIC,MAAT,IAAmBF,QAAnB,EAA6B;AAC3B,iBAAKH,mBAAL,CAAyBH,GAAzB,CAA6BQ,OAAOT,GAApC,EAAyC;AACvCU,qBAASD,MAD8B;AAEvCH,mBAAOf,mBAAmBoB,GAAnB,CAAuBF,OAAOT,GAA9B;AAFgC,WAAzC;AAID;;AAAA;AACF;;AACD,aAAO,OAAKI,mBAAZ;AAlBiD;AAmBlD;AAED;;;;;;;AAKMQ,oBAAN,CAAyBP,SAAzB,EAAoCI,MAApC,EAA4C;AAAA;;AAAA;AAC1C,UAAIA,UAAU,IAAV,IAAkBA,UAAU,MAAhC,EAAwC;AACtC,cAAM,IAAIpC,KAAJ,CAAW,sDAAqDoC,MAAO,GAAvE,CAAN;AACD;;AACD,YAAM3C,eAAe,OAAKA,MAAL,EAArB;AACA,YAAMgB,aAAa,OAAKA,IAAL,CAAU;AAAEC,mBAAW;AAAb,OAAV,CAAnB;AACA,YAAMoB,2BAA2B,OAAKA,kBAAL,EAAjC;;AACA,UAAIM,UAAU,IAAV,IAAkB,CAACN,mBAAmBQ,GAAnB,CAAuBN,UAAUL,GAAjC,EAAsCU,OAA7D,EAAsE;AACpE,cAAM5B,KAAKQ,KAAL,CAAY,gBAAexB,OAAOa,mBAAoB,mCAAtD,EAA0F,CAC9F0B,UAAUL,GADoF,EAE9F3C,KAAKwD,QAAL,CAAcR,UAAUH,IAAxB,EAA8B,KAA9B,CAF8F,CAA1F,CAAN;AAID,OALD,MAKO,IAAIO,UAAU,MAAV,IAAoBN,mBAAmBQ,GAAnB,CAAuBN,UAAUL,GAAjC,EAAsCU,OAA9D,EAAuE;AAC5E,cAAM5B,KAAKQ,KAAL,CAAY,gBAAexB,OAAOa,mBAAoB,kBAAtD,EAAyE,CAC7E0B,UAAUL,GADmE,CAAzE,CAAN;AAGD;AAhByC;AAiB3C;AAED;;;;;;;AAKMc,mBAAN,CAAwBC,EAAxB,EAA4B;AAAA;;AAAA;AAC1B,UAAI,OAAKC,kBAAT,EAA6B;AAC3B,qBAAaD,IAAb;AACD,OAFD,MAEO;AACL,cAAMjD,eAAe,OAAKA,MAAL,EAArB;AACA,cAAMgB,aAAa,OAAKA,IAAL,CAAU;AAAEC,qBAAW;AAAb,SAAV,CAAnB;AACA,eAAKiC,kBAAL,GAA0B,IAA1B;AACA,cAAMlC,KAAKQ,KAAL,CAAY,oCAAmCxB,OAAOa,mBAAoB,GAA1E,CAAN;;AACA,YAAI;AACF,uBAAaoC,IAAb;AACD,SAFD,SAEU;AACR,gBAAMjC,KAAKQ,KAAL,CAAY,sCAAqCxB,OAAOa,mBAAoB,GAA5E,CAAN;AACA,iBAAKqC,kBAAL,GAA0B,KAA1B;AACD;AACF;AAdyB;AAe3B;AAED;;;;;;;AAKMC,iBAAN,CAAsBF,EAAtB,EAA0B;AAAA;;AAAA;AACxB,UAAI,OAAKG,gBAAT,EAA2B;AACzB,qBAAaH,IAAb;AACD,OAFD,MAEO;AACL,cAAMjD,eAAe,OAAKA,MAAL,EAArB;AACA,cAAMgB,aAAa,OAAKA,IAAL,EAAnB;AACA,eAAKoC,gBAAL,GAAwB,IAAxB;AACA,cAAMpC,KAAKQ,KAAL,CAAY,OAAZ,CAAN;;AACA,YAAI;AACF,cAAI6B,eAAeJ,IAAnB;AACA,gBAAMjC,KAAKQ,KAAL,CAAW,QAAX,CAAN;AACA,iBAAO6B,MAAP;AACD,SAJD,CAIE,OAAMC,SAAN,EAAiB;AACjB,gBAAMtC,KAAKQ,KAAL,CAAW,UAAX,CAAN;AACA,gBAAM8B,SAAN;AACD,SAPD,SAOU;AACR,iBAAKF,gBAAL,GAAwB,KAAxB;AACD;AACF;AAlBuB;AAmBzB;;AAzLmC,CAAtC;AA4LA3D,OAAOC,OAAP,CAAeF,eAAf,GAAiCA,eAAjC","file":"migrations_host.js","sourcesContent":["const FS = require('async-file');\nconst Path = require('path');\n\nconst CONFIG_FILENAME = \"migrations.config.js\";\n\n/**\n * Represents a host application using the pg-migrations library.\n */\nmodule.exports = class MigrationsHost {\n  constructor(rootPath = null) {\n    this.rootPath = rootPath || process.cwd();\n  }\n\n  /**\n   * Gets the migrations configuration of the client application, which includes the name of the migrations table, the relative path of where migration files are kept, and a method to get a connection to the database.\n   * @return {Promise<{ configPath: string, migrationsTableName: string, migrationsPath: string, migrationsRelPath: string, getConnection: function }>}\n   */\n  async config() {\n    if (!this._config) {\n      while (true) {\n        if (await FS.exists(Path.join(this.rootPath, CONFIG_FILENAME), FS.constants.R_OK)) {\n          break;\n        }\n        this.rootPath = Path.dirname(this.rootPath);\n        if (this.rootPath == \"/\") {\n          throw new Error(`Cannot find ${CONFIG_FILENAME}`);\n        }\n      }\n      let loadedConfig = require(Path.join(this.rootPath, CONFIG_FILENAME));\n      if (loadedConfig.default) {\n        loadedConfig = loadedConfig.default;\n      }\n      this._config = Object.assign({\n        configPath: Path.join(this.rootPath, CONFIG_FILENAME),\n        migrationsTableName: \"migrations\",\n        migrationsRelPath: \"./migrations\",\n      }, loadedConfig);\n      this._config.migrationsPath = Path.join(this.rootPath, this._config.migrationsRelPath);\n    }\n    return this._config;\n  }\n\n  /**\n   * Gets a connection to the database, can optionally bootstrap the migrations table.\n   * @param {{ bootstrap: boolean }} opt - If bootstrap is true, will ensure the migrations table exists. Default value is false.\n   * @return {Promise<pg.Client>}\n   */\n  async conn({ bootstrap = false } = {}) {\n    if (!this._conn) {\n      const config = await this.config();\n      if (typeof(config.getConnection) !== 'function') {\n        throw new Error(`${config.configPath} does not define a getConnection method, is '${typeof(config.getConnection)}'`);\n      }\n      this._conn = await config.getConnection();\n      if (!this._conn._connecting && !this._conn._connected) {\n        await this._conn.connect();\n      }\n    }\n    if (bootstrap && !this._bootstrapped) {\n      const config = await this.config();\n      await this._conn.query(`\n        create table if not exists \"${config.migrationsTableName}\" (\n          \"key\" varchar(14) primary key not null,\n          \"filename\" varchar(255) not null,\n          \"migrated_at\" timestamp with time zone not null default timezone('utc'::text, now())\n        );\n      `);\n      this._bootstrapped = true;\n    }\n    return this._conn;\n  }\n\n  /**\n   * Gets a map of migration keys to the information about the migration on disk, like the filename and path.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the local migrations map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ key: string, filename: string, path: string }>>}\n   */\n  async localMigrationsMap({ refresh = false } = {}) {\n    if (!this._localMigrationsMap || refresh) {\n      const config = await this.config();\n      const files = await FS.readdir(config.migrationsPath);\n      this._localMigrationsMap = new Map();\n      for (let filename of files) {\n        const keySearch = filename.match(/([0-9]{12,14})/);\n        if (keySearch) {\n          const key = keySearch[1];\n          this._localMigrationsMap.set(key, {\n            key,\n            filename,\n            path: Path.join(config.migrationsPath, filename),\n          });\n        }\n      }\n    }\n    return this._localMigrationsMap;\n  }\n\n  /**\n   * Gets a map of migration status, including both applied and local migrations on disk independent of status.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the migration status map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ applied: { key: string, filename: string, migrated_at: string }, local: { key: string, filename: string, path: string } }>>}\n   */\n  async migrationStatusMap({ refresh = false } = {}) {\n    if (!this._migrationStatusMap || refresh) {\n      const localMigrationsMap = await this.localMigrationsMap();\n      this._migrationStatusMap = new Map();\n      for(let [key, migration] of localMigrationsMap) {\n        this._migrationStatusMap.set(key, { local: migration });\n      }\n\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      const statuses = (await conn.query(`select \"key\", \"filename\", \"migrated_at\" from \"${config.migrationsTableName}\" order by \"migrated_at\"`)).rows;\n      for (let status of statuses) {\n        this._migrationStatusMap.set(status.key, {\n          applied: status,\n          local: localMigrationsMap.get(status.key),\n        });\n      };\n    }\n    return this._migrationStatusMap;\n  }\n\n  /**\n   * Sets a migration status.\n   * @param {{ key: string, filename: string, path: string }} migration\n   * @param {string} status - Must be either 'up' or 'down'.\n   */\n  async setMigrationStatus(migration, status) {\n    if (status != 'up' && status != 'down') {\n      throw new Error(`Unhandled status, must be 'up' or 'down' but was: '${status}'`);\n    }\n    const config = await this.config();\n    const conn = await this.conn({ bootstrap: true });\n    const migrationStatusMap = await this.migrationStatusMap();\n    if (status == 'up' && !migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`insert into \"${config.migrationsTableName}\" (key, filename) values ($1, $2)`, [\n        migration.key,\n        Path.basename(migration.path, \".js\"),\n      ]);\n    } else if (status == 'down' && migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`delete from \"${config.migrationsTableName}\" where key = $1`, [\n        migration.key,\n      ]);\n    }\n  }\n\n  /**\n   * Acquires a global migration lock, so multiple agents trying to run migrations at the same time wont apply them multiple times.\n   * @param {function} fn - Asynchronoush function is called while the migration lock is held. When the provided function ends, the migration lock is released.\n   * @return {Promise}\n   */\n  async withMigrationLock(fn) {\n    if (this._withMigrationLock) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      this._withMigrationLock = true;\n      await conn.query(`select pg_advisory_lock(1) from \"${config.migrationsTableName}\"`);\n      try {\n        return await fn();\n      } finally {\n        await conn.query(`select pg_advisory_unlock(1) from \"${config.migrationsTableName}\"`);\n        this._withMigrationLock = false;\n      }\n    }\n  }\n\n  /**\n   * Starts a transaction for the duration of the provided asynchronous function. If any exceptions are thrown, the transaction is rolled back, otherwise, it is committed.\n   * @param {function} fn - Asynchronoush function is called while the migration is open.\n   * @return {Promise}\n   */\n  async withTransaction(fn) {\n    if (this._withTransaction) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn();\n      this._withTransaction = true;\n      await conn.query(`begin`);\n      try {\n        let result = await fn();\n        await conn.query(\"commit\");\n        return result;\n      } catch(exception) {\n        await conn.query(\"rollback\");\n        throw exception;\n      } finally {\n        this._withTransaction = false;\n      }\n    }\n  }\n}\n\nmodule.exports.CONFIG_FILENAME = CONFIG_FILENAME;\n"]}