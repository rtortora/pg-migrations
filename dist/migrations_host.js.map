{"version":3,"sources":["../src/migrations_host.js"],"names":["FS","require","Path","CONFIG_FILENAME","module","exports","MigrationsHost","constructor","rootPath","process","cwd","config","_config","exists","join","constants","R_OK","dirname","Error","loadedConfig","default","Object","assign","configPath","migrationsTableName","migrationsRelPath","migrationsPath","conn","bootstrap","_conn","getConnection","_connecting","_connected","connect","_bootstrapped","query","localMigrationsMap","refresh","_localMigrationsMap","files","readdir","Map","filename","keySearch","match","key","set","path","migrationStatusMap","_migrationStatusMap","migration","local","statuses","rows","status","applied","get","setMigrationStatus","basename","withMigrationLock","fn","_withMigrationLock","withTransaction","_withTransaction","result","exception"],"mappings":"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","sourcesContent":["const FS = require('async-file');\nconst Path = require('path');\n\nconst CONFIG_FILENAME = \"migrations.config.js\";\n\n/**\n * Represents a host application using the pg-migrations library.\n */\nmodule.exports = class MigrationsHost {\n  constructor(rootPath = null) {\n    this.rootPath = rootPath || process.cwd();\n  }\n\n  /**\n   * Gets the migrations configuration of the client application, which includes the name of the migrations table, the relative path of where migration files are kept, and a method to get a connection to the database.\n   * @return {Promise<{ configPath: string, migrationsTableName: string, migrationsPath: string, migrationsRelPath: string, getConnection: function }>}\n   */\n  async config() {\n    if (!this._config) {\n      while (true) {\n        if (await FS.exists(Path.join(this.rootPath, CONFIG_FILENAME), FS.constants.R_OK)) {\n          break;\n        }\n        this.rootPath = Path.dirname(this.rootPath);\n        if (this.rootPath == \"/\") {\n          throw new Error(`Cannot find ${CONFIG_FILENAME}`);\n        }\n      }\n      let loadedConfig = require(Path.join(this.rootPath, CONFIG_FILENAME));\n      if (loadedConfig.default) {\n        loadedConfig = loadedConfig.default;\n      }\n      this._config = Object.assign({\n        configPath: Path.join(this.rootPath, CONFIG_FILENAME),\n        migrationsTableName: \"migrations\",\n        migrationsRelPath: \"./migrations\",\n      }, loadedConfig);\n      this._config.migrationsPath = Path.join(this.rootPath, this._config.migrationsRelPath);\n    }\n    return this._config;\n  }\n\n  /**\n   * Gets a connection to the database, can optionally bootstrap the migrations table.\n   * @param {{ bootstrap: boolean }} opt - If bootstrap is true, will ensure the migrations table exists. Default value is false.\n   * @return {Promise<pg.Client>}\n   */\n  async conn({ bootstrap = false } = {}) {\n    if (!this._conn) {\n      const config = await this.config();\n      if (typeof(config.getConnection) !== 'function') {\n        throw new Error(`${config.configPath} does not define a getConnection method, is '${typeof(config.getConnection)}'`);\n      }\n      this._conn = await config.getConnection();\n      if (!this._conn._connecting && !this._conn._connected) {\n        await this._conn.connect();\n      }\n    }\n    if (bootstrap && !this._bootstrapped) {\n      const config = await this.config();\n      await this._conn.query(`\n        create table if not exists \"${config.migrationsTableName}\" (\n          \"key\" varchar(14) primary key not null,\n          \"filename\" varchar(255) not null,\n          \"migrated_at\" timestamp with time zone not null default timezone('utc'::text, now())\n        );\n      `);\n      this._bootstrapped = true;\n    }\n    return this._conn;\n  }\n\n  /**\n   * Gets a map of migration keys to the information about the migration on disk, like the filename and path.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the local migrations map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ key: string, filename: string, path: string }>>}\n   */\n  async localMigrationsMap({ refresh = false } = {}) {\n    if (!this._localMigrationsMap || refresh) {\n      const config = await this.config();\n      const files = await FS.readdir(config.migrationsPath);\n      this._localMigrationsMap = new Map();\n      for (let filename of files) {\n        const keySearch = filename.match(/([0-9]{12,14})/);\n        if (keySearch) {\n          const key = keySearch[1];\n          this._localMigrationsMap.set(key, {\n            key,\n            filename,\n            path: Path.join(config.migrationsPath, filename),\n          });\n        }\n      }\n    }\n    return this._localMigrationsMap;\n  }\n\n  /**\n   * Gets a map of migration status, including both applied and local migrations on disk independent of status.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the migration status map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ applied: { key: string, filename: string, migrated_at: string }, local: { key: string, filename: string, path: string } }>>}\n   */\n  async migrationStatusMap({ refresh = false } = {}) {\n    if (!this._migrationStatusMap || refresh) {\n      const localMigrationsMap = await this.localMigrationsMap();\n      this._migrationStatusMap = new Map();\n      for(let [key, migration] of localMigrationsMap) {\n        this._migrationStatusMap.set(key, { local: migration });\n      }\n\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      const statuses = (await conn.query(`select \"key\", \"filename\", \"migrated_at\" from \"${config.migrationsTableName}\" order by \"migrated_at\"`)).rows;\n      for (let status of statuses) {\n        this._migrationStatusMap.set(status.key, {\n          applied: status,\n          local: localMigrationsMap.get(status.key),\n        });\n      };\n    }\n    return this._migrationStatusMap;\n  }\n\n  /**\n   * Sets a migration status.\n   * @param {{ key: string, filename: string, path: string }} migration\n   * @param {string} status - Must be either 'up' or 'down'.\n   */\n  async setMigrationStatus(migration, status) {\n    if (status != 'up' && status != 'down') {\n      throw new Error(`Unhandled status, must be 'up' or 'down' but was: '${status}'`);\n    }\n    const config = await this.config();\n    const conn = await this.conn({ bootstrap: true });\n    const migrationStatusMap = await this.migrationStatusMap();\n    if (status == 'up' && !migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`insert into \"${config.migrationsTableName}\" (key, filename) values ($1, $2)`, [\n        migration.key,\n        Path.basename(migration.path, \".js\"),\n      ]);\n    } else if (status == 'down' && migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`delete from \"${config.migrationsTableName}\" where key = $1`, [\n        migration.key,\n      ]);\n    }\n  }\n\n  /**\n   * Acquires a global migration lock, so multiple agents trying to run migrations at the same time wont apply them multiple times.\n   * @param {function} fn - Asynchronoush function is called while the migration lock is held. When the provided function ends, the migration lock is released.\n   * @return {Promise}\n   */\n  async withMigrationLock(fn) {\n    if (this._withMigrationLock) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      this._withMigrationLock = true;\n      await conn.query(`select pg_advisory_lock(1) from \"${config.migrationsTableName}\"`);\n      try {\n        return await fn();\n      } finally {\n        await conn.query(`select pg_advisory_unlock(1) from \"${config.migrationsTableName}\"`);\n        this._withMigrationLock = false;\n      }\n    }\n  }\n\n  /**\n   * Starts a transaction for the duration of the provided asynchronous function. If any exceptions are thrown, the transaction is rolled back, otherwise, it is committed.\n   * @param {function} fn - Asynchronoush function is called while the migration is open.\n   * @return {Promise}\n   */\n  async withTransaction(fn) {\n    if (this._withTransaction) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn();\n      this._withTransaction = true;\n      await conn.query(`begin`);\n      try {\n        let result = await fn();\n        await conn.query(\"commit\");\n        return result;\n      } catch(exception) {\n        await conn.query(\"rollback\");\n        throw exception;\n      } finally {\n        this._withTransaction = false;\n      }\n    }\n  }\n}\n\nmodule.exports.CONFIG_FILENAME = CONFIG_FILENAME;\n"],"file":"migrations_host.js"}