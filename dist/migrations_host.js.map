{"version":3,"sources":["../src/migrations_host.js"],"names":["FS","require","Path","CONFIG_FILENAME","module","exports","MigrationsHost","constructor","rootPath","process","cwd","config","_config","exists","join","constants","R_OK","dirname","Error","loadedConfig","default","Object","assign","configPath","migrationsTableName","migrationsRelPath","migrationsPath","conn","bootstrap","_conn","getConnection","_connecting","_connected","connect","_bootstrapped","query","localMigrationsMap","refresh","_localMigrationsMap","Map","_scanFolderIntoLocalMigrationsMap","checkSubfolders","path","filename","readdir","stat","isDirectory","keySearch","match","key","set","tidySearch","console","log","migrationStatusMap","_migrationStatusMap","migration","local","statuses","rows","status","applied","get","setMigrationStatus","basename","withMigrationLock","fn","_withMigrationLock","withTransaction","_withTransaction","result","exception"],"mappings":"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","sourcesContent":["const FS = require('async-file');\nconst Path = require('path');\n\nconst CONFIG_FILENAME = \"migrations.config.js\";\n\n/**\n * Represents a host application using the pg-migrations library.\n */\nmodule.exports = class MigrationsHost {\n  constructor(rootPath = null) {\n    this.rootPath = rootPath || process.cwd();\n  }\n\n  /**\n   * Gets the migrations configuration of the client application, which includes the name of the migrations table, the relative path of where migration files are kept, and a method to get a connection to the database.\n   * @return {Promise<{ configPath: string, migrationsTableName: string, migrationsPath: string, migrationsRelPath: string, getConnection: function }>}\n   */\n  async config() {\n    if (!this._config) {\n      while (true) {\n        if (await FS.exists(Path.join(this.rootPath, CONFIG_FILENAME), FS.constants.R_OK)) {\n          break;\n        }\n        this.rootPath = Path.dirname(this.rootPath);\n        if (this.rootPath == \"/\") {\n          throw new Error(`Cannot find ${CONFIG_FILENAME}`);\n        }\n      }\n      let loadedConfig = require(Path.join(this.rootPath, CONFIG_FILENAME));\n      if (loadedConfig.default) {\n        loadedConfig = loadedConfig.default;\n      }\n      this._config = Object.assign({\n        configPath: Path.join(this.rootPath, CONFIG_FILENAME),\n        migrationsTableName: \"migrations\",\n        migrationsRelPath: \"./migrations\",\n      }, loadedConfig);\n      this._config.migrationsPath = Path.join(this.rootPath, this._config.migrationsRelPath);\n    }\n    return this._config;\n  }\n\n  /**\n   * Gets a connection to the database, can optionally bootstrap the migrations table.\n   * @param {{ bootstrap: boolean }} opt - If bootstrap is true, will ensure the migrations table exists. Default value is false.\n   * @return {Promise<pg.Client>}\n   */\n  async conn({ bootstrap = false } = {}) {\n    if (!this._conn) {\n      const config = await this.config();\n      if (typeof(config.getConnection) !== 'function') {\n        throw new Error(`${config.configPath} does not define a getConnection method, is '${typeof(config.getConnection)}'`);\n      }\n      this._conn = await config.getConnection();\n      if (!this._conn._connecting && !this._conn._connected) {\n        await this._conn.connect();\n      }\n    }\n    if (bootstrap && !this._bootstrapped) {\n      const config = await this.config();\n      await this._conn.query(`\n        create table if not exists \"${config.migrationsTableName}\" (\n          \"key\" varchar(14) primary key not null,\n          \"filename\" varchar(255) not null,\n          \"migrated_at\" timestamp with time zone not null default timezone('utc'::text, now())\n        );\n      `);\n      this._bootstrapped = true;\n    }\n    return this._conn;\n  }\n\n  /**\n   * Gets a map of migration keys to the information about the migration on disk, like the filename and path.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the local migrations map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ key: string, filename: string, path: string }>>}\n   */\n  async localMigrationsMap({ refresh = false } = {}) {\n    if (!this._localMigrationsMap || refresh) {\n      const config = await this.config();\n      this._localMigrationsMap = new Map();\n      await this._scanFolderIntoLocalMigrationsMap(config, config.migrationsPath, {\n        checkSubfolders: true,\n      });\n    }\n    return this._localMigrationsMap;\n  }\n\n  async _scanFolderIntoLocalMigrationsMap(config, path, { checkSubfolders = true } = {}) {\n    for (let filename of await FS.readdir(path)) {\n      if ((await FS.stat(Path.join(path, filename))).isDirectory()) {\n        await this._scanFolderIntoLocalMigrationsMap(config, Path.join(path, filename), { checkSubfolders: true });\n      } else {\n        const keySearch = filename.match(/(^[0-9]{12,14})/);\n        if (keySearch) {\n          const key = keySearch[1];\n          this._localMigrationsMap.set(key, {\n            key,\n            filename,\n            path: Path.join(config.migrationsPath, filename),\n          });\n        } else {\n          const tidySearch = filename.match(/^[0-9]{4}-[0-9]{2}$/i);\n          if (tidySearch) {\n            console.log(`GOT HERE!!! ${tidySearch}`);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets a map of migration status, including both applied and local migrations on disk independent of status.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the migration status map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ applied: { key: string, filename: string, migrated_at: string }, local: { key: string, filename: string, path: string } }>>}\n   */\n  async migrationStatusMap({ refresh = false } = {}) {\n    if (!this._migrationStatusMap || refresh) {\n      const localMigrationsMap = await this.localMigrationsMap();\n      this._migrationStatusMap = new Map();\n      for(let [key, migration] of localMigrationsMap) {\n        this._migrationStatusMap.set(key, { local: migration });\n      }\n\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      const statuses = (await conn.query(`select \"key\", \"filename\", \"migrated_at\" from \"${config.migrationsTableName}\" order by \"migrated_at\"`)).rows;\n      for (let status of statuses) {\n        this._migrationStatusMap.set(status.key, {\n          applied: status,\n          local: localMigrationsMap.get(status.key),\n        });\n      };\n    }\n    return this._migrationStatusMap;\n  }\n\n  /**\n   * Sets a migration status.\n   * @param {{ key: string, filename: string, path: string }} migration\n   * @param {string} status - Must be either 'up' or 'down'.\n   */\n  async setMigrationStatus(migration, status) {\n    if (status != 'up' && status != 'down') {\n      throw new Error(`Unhandled status, must be 'up' or 'down' but was: '${status}'`);\n    }\n    const config = await this.config();\n    const conn = await this.conn({ bootstrap: true });\n    const migrationStatusMap = await this.migrationStatusMap();\n    if (status == 'up' && !migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`insert into \"${config.migrationsTableName}\" (key, filename) values ($1, $2)`, [\n        migration.key,\n        Path.basename(migration.path, \".js\"),\n      ]);\n    } else if (status == 'down' && migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`delete from \"${config.migrationsTableName}\" where key = $1`, [\n        migration.key,\n      ]);\n    }\n  }\n\n  /**\n   * Acquires a global migration lock, so multiple agents trying to run migrations at the same time wont apply them multiple times.\n   * @param {function} fn - Asynchronoush function is called while the migration lock is held. When the provided function ends, the migration lock is released.\n   * @return {Promise}\n   */\n  async withMigrationLock(fn) {\n    if (this._withMigrationLock) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      this._withMigrationLock = true;\n      await conn.query(`select pg_advisory_lock(1) from \"${config.migrationsTableName}\"`);\n      try {\n        return await fn();\n      } finally {\n        await conn.query(`select pg_advisory_unlock(1) from \"${config.migrationsTableName}\"`);\n        this._withMigrationLock = false;\n      }\n    }\n  }\n\n  /**\n   * Starts a transaction for the duration of the provided asynchronous function. If any exceptions are thrown, the transaction is rolled back, otherwise, it is committed.\n   * @param {function} fn - Asynchronoush function is called while the migration is open.\n   * @return {Promise}\n   */\n  async withTransaction(fn) {\n    if (this._withTransaction) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn();\n      this._withTransaction = true;\n      await conn.query(`begin`);\n      try {\n        let result = await fn();\n        await conn.query(\"commit\");\n        return result;\n      } catch(exception) {\n        await conn.query(\"rollback\");\n        throw exception;\n      } finally {\n        this._withTransaction = false;\n      }\n    }\n  }\n}\n\nmodule.exports.CONFIG_FILENAME = CONFIG_FILENAME;\n"],"file":"migrations_host.js"}