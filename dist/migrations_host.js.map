{"version":3,"sources":["../src/migrations_host.js"],"names":["CONFIG_FILENAME","MigrationsHost","constructor","rootPath","process","cwd","config","_config","exists","join","constants","R_OK","dirname","Error","loadedConfig","require","default","configPath","migrationsTableName","migrationsRelPath","migrationsPath","conn","bootstrap","_conn","getConnection","_connecting","_connected","connect","_bootstrapped","query","localMigrationsMap","refresh","_localMigrationsMap","files","readdir","Map","filename","keySearch","match","key","set","path","migrationStatusMap","_migrationStatusMap","migration","local","statuses","rows","status","applied","get","setMigrationStatus","basename","withMigrationLock","fn","_withMigrationLock","withTransaction","_withTransaction","result","exception"],"mappings":"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","file":"migrations_host.js","sourcesContent":["import FS from 'async-file';\nimport Path from 'path';\nimport map from 'lodash.map';\nimport forEach from 'lodash.foreach';\nimport isFunction from 'lodash.isfunction';\nimport merge from 'lodash.merge';\n\nexport const CONFIG_FILENAME = \"migrations.config.js\";\n\n/**\n * Represents a host application using the pg-migrations library.\n */\nexport default class MigrationsHost {\n  constructor(rootPath = null) {\n    this.rootPath = rootPath || process.cwd();\n  }\n\n  /**\n   * Gets the migrations configuration of the client application, which includes the name of the migrations table, the relative path of where migration files are kept, and a method to get a connection to the database.\n   * @return {Promise<{ configPath: string, migrationsTableName: string, migrationsPath: string, migrationsRelPath: string, getConnection: function }>}\n   */\n  async config() {\n    if (!this._config) {\n      while (true) {\n        if (await FS.exists(Path.join(this.rootPath, CONFIG_FILENAME), FS.constants.R_OK)) {\n          break;\n        }\n        this.rootPath = Path.dirname(this.rootPath);\n        if (this.rootPath == \"/\") {\n          throw new Error(`Cannot find ${CONFIG_FILENAME}`);\n        }\n      }\n      const loadedConfig = require(Path.join(this.rootPath, CONFIG_FILENAME)).default;\n      this._config = merge({\n        configPath: Path.join(this.rootPath, CONFIG_FILENAME),\n        migrationsTableName: \"migrations\",\n        migrationsRelPath: \"./migrations\",\n      }, loadedConfig);\n      this._config.migrationsPath = Path.join(this.rootPath, this._config.migrationsRelPath);\n    }\n    return this._config;\n  }\n\n  /**\n   * Gets a connection to the database, can optionally bootstrap the migrations table.\n   * @param {{ bootstrap: boolean }} opt - If bootstrap is true, will ensure the migrations table exists. Default value is false.\n   * @return {Promise<pg.Client>}\n   */\n  async conn({ bootstrap = false } = {}) {\n    if (!this._conn) {\n      const config = await this.config();\n      if (!isFunction(config.getConnection)) {\n        throw new Error(`${config.configPath} does not define a getConnection method`);\n      }\n      this._conn = await config.getConnection();\n      if (!this._conn._connecting && !this._conn._connected) {\n        await this._conn.connect();\n      }\n    }\n    if (bootstrap && !this._bootstrapped) {\n      const config = await this.config();\n      await this._conn.query(`\n        create table if not exists \"${config.migrationsTableName}\" (\n          \"key\" varchar(14) primary key not null,\n          \"filename\" varchar(255) not null,\n          \"migrated_at\" timestamp with time zone not null default timezone('utc'::text, now())\n        );\n      `);\n      this._bootstrapped = true;\n    }\n    return this._conn;\n  }\n\n  /**\n   * Gets a map of migration keys to the information about the migration on disk, like the filename and path.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the local migrations map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ key: string, filename: string, path: string }>>}\n   */\n  async localMigrationsMap({ refresh = false } = {}) {\n    if (!this._localMigrationsMap || refresh) {\n      const config = await this.config();\n      const files = await FS.readdir(config.migrationsPath);\n      this._localMigrationsMap = new Map();\n      forEach(files, (filename)=>{\n        const keySearch = filename.match(/([0-9]{12,14})/);\n        if (keySearch) {\n          const key = keySearch[1];\n          this._localMigrationsMap.set(key, {\n            key,\n            filename,\n            path: Path.join(config.migrationsPath, filename),\n          });\n        }\n      });\n    }\n    return this._localMigrationsMap;\n  }\n\n  /**\n   * Gets a map of migration status, including both applied and local migrations on disk independent of status.\n   * @param {{ refresh: boolean }} opt - If refresh is true, will freshly fetch the migration status map, otherwise will use the values from the last call (if any). Default value is false.\n   * @return {Promise<Map<string:{ applied: { key: string, filename: string, migrated_at: string }, local: { key: string, filename: string, path: string } }>>}\n   */\n  async migrationStatusMap({ refresh = false } = {}) {\n    if (!this._migrationStatusMap || refresh) {\n      const localMigrationsMap = await this.localMigrationsMap();\n      this._migrationStatusMap = new Map();\n      for(let [key, migration] of localMigrationsMap) {\n        this._migrationStatusMap.set(key, { local: migration });\n      }\n\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      const statuses = (await conn.query(`select \"key\", \"filename\", \"migrated_at\" from \"${config.migrationsTableName}\" order by \"migrated_at\"`)).rows;\n      forEach(statuses, (status)=>{\n        this._migrationStatusMap.set(status.key, {\n          applied: status,\n          local: localMigrationsMap.get(status.key),\n        });\n      });\n    }\n    return this._migrationStatusMap;\n  }\n\n  /**\n   * Sets a migration status.\n   * @param {{ key: string, filename: string, path: string }} migration\n   * @param {string} status - Must be either 'up' or 'down'.\n   */\n  async setMigrationStatus(migration, status) {\n    if (status != 'up' && status != 'down') {\n      throw new Error(`Unhandled status, must be 'up' or 'down' but was: '${status}'`);\n    }\n    const config = await this.config();\n    const conn = await this.conn({ bootstrap: true });\n    const migrationStatusMap = await this.migrationStatusMap();\n    if (status == 'up' && !migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`insert into \"${config.migrationsTableName}\" (key, filename) values ($1, $2)`, [\n        migration.key,\n        Path.basename(migration.path, \".js\"),\n      ]);\n    } else if (status == 'down' && migrationStatusMap.get(migration.key).applied) {\n      await conn.query(`delete from \"${config.migrationsTableName}\" where key = $1`, [\n        migration.key,\n      ]);\n    }\n  }\n\n  /**\n   * Acquires a global migration lock, so multiple agents trying to run migrations at the same time wont apply them multiple times.\n   * @param {function} fn - Asynchronoush function is called while the migration lock is held. When the provided function ends, the migration lock is released.\n   * @return {Promise}\n   */\n  async withMigrationLock(fn) {\n    if (this._withMigrationLock) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn({ bootstrap: true });\n      this._withMigrationLock = true;\n      await conn.query(`select pg_advisory_lock(1) from \"${config.migrationsTableName}\"`);\n      try {\n        return await fn();\n      } finally {\n        await conn.query(`select pg_advisory_unlock(1) from \"${config.migrationsTableName}\"`);\n        this._withMigrationLock = false;\n      }\n    }\n  }\n\n  /**\n   * Starts a transaction for the duration of the provided asynchronous function. If any exceptions are thrown, the transaction is rolled back, otherwise, it is committed.\n   * @param {function} fn - Asynchronoush function is called while the migration is open.\n   * @return {Promise}\n   */\n  async withTransaction(fn) {\n    if (this._withTransaction) {\n      return await fn();\n    } else {\n      const config = await this.config();\n      const conn = await this.conn();\n      this._withTransaction = true;\n      await conn.query(`begin`);\n      try {\n        let result = await fn();\n        await conn.query(\"commit\");\n        return result;\n      } catch(exception) {\n        await conn.query(\"rollback\");\n        throw exception;\n      } finally {\n        this._withTransaction = false;\n      }\n    }\n  }\n}"]}